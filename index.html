<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Label AI</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%220.9em%22 font-size=%2290%22>üî∫</text></svg>">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="container"> <!-- Start page container -->

    <!-- Heading and nav -->
    <h1 class="mb-4 text-center">üî∫ Label AI</h1>
    <ul class="nav nav-tabs mb-4">
      <li class="nav-item">
        <a class="nav-link active" href="index.html">üñº Images</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="text.html">üìù Text</a>
      </li>
    </ul>

    <!-- Start image frame -->
    <div id="imageFrame" class="border border-dashed border-3 rounded text-center p-5" style="position: relative; overflow: hidden;">
      <div id="popoverContainer" style="position: absolute; top: 10px; right: 10px; z-index: 10;" class="d-none">
        <cai-popover interactive>
          <cai-indicator slot="trigger"></cai-indicator>
          <div id="manifest-summary" slot="content" style="width: 300px">
            <h4>Content Credentials</h4>
            <p style="font-size:90%; color:#bcbcbc;">Issued by <span id="manifest-summary-issuer"></span> on <span id="manifest-summary-date"></span></p>
            <hr />
            <p><b>Title:</b> <span id="manifest-summary-title"></span></p>
            <hr />
            <p><b>Recorder:</b> <span id="manifest-summary-recorder"></span></p>
            <hr />
            <p><b>Content tag:</b> <span id="manifest-summary-content-tag"></span></p>
          </div>
        </cai-popover>
      </div> 
      <p id="placeholderText">
        <label class="form-label">Drag an image, Ctrl-V to paste from the clipboard,<br /><a href="#" id="uploadImageLink">or click here to open an image file</a></label>
      </p>
      <canvas id="canvas" class="d-none"></canvas>
    </div> <!-- End image frame -->

    <!-- Start form -->
    <div class="d-flex flex-wrap">
      <div class="mb-4 flex-fill me-4">
        <label class="form-label">Add a label</label>
        <div class="form-check">
          <input class="form-check-input" type="radio" name="labelOption" id="generatedLabel" value="generated" checked>
          <label class="form-check-label" for="generatedLabel">Generated by AI</label>
        </div>
        <div class="form-check">
          <input class="form-check-input" type="radio" name="labelOption" id="chooseModelLabel" value="model">
          <label class="form-check-label" for="chooseModelLabel">Choose a model</label>
          <select id="modelDropdown" class="form-select mt-2" disabled>
            <option value="DALL-E">DALL-E</option>
            <option value="Microsoft Copilot">Microsoft Copilot</option>
            <option value="Midjourney">Midjourney</option>
            <option value="Imagen">Imagen</option>
          </select>
        </div>
        <div class="form-check">
          <input class="form-check-input" type="radio" name="labelOption" id="useAILabel" value="ai-label">
          <label class="form-check-label" for="useAILabel">Use ai-label.org</label>
        </div>
        <div class="form-check">
          <input class="form-check-input" type="radio" name="labelOption" id="freeInputOption" value="free">
          <label class="form-check-label" for="freeInputOption">Your own label</label>
          <input class="form-control" type="text" id="freeInput" placeholder="Free text"/>
        </div>
      </div>

      <div class="mb-4 flex-fill">
        <label for="hiddenPrompt" class="form-label">Embed text (optional)</label>
        <textarea id="hiddenPrompt" class="form-control" rows="7" placeholder="E.g. Model, version, date, prompt..."></textarea>
      </div>
    </div>

    <!-- Big buttons -->
    <div class="d-flex gap-2 mb-4">
      <button id="labelButton" class="btn btn-primary flex-grow-1">Label image and copy to clipboard</button>
      <button id="clearButton" class="btn btn-danger flex-grow-2">Clear</button>
    </div>

    <div class="card"> <!-- Start card -->
      <div class="card-header" id="how-collapse-heading">
        <h5 class="mb-0">
          <button class="btn btn-link" data-toggle="collapse" data-target="#how-collapse" aria-expanded="true" aria-controls="how-collapse">
            How does it work?
          </button>
        </h5>
      </div>
      <div id="how-collapse" class="collapse show" aria-labelledby="how-collapse-heading">
        <div class="card-body">
          The labels are inserted into the image, they cannot be easily removed except by cropping.
          The optional text is embedded in the alpha channel of the image using
          <a href="https://en.wikipedia.org/wiki/Steganography">steganography</a>.
          If present, <a href="https://contentcredentials.org/">Content Credentials</a> are detected
          and made available via the <b>cr</b> logo in the image frame.
        </div>
      </div>
    </div> <!-- End card -->

    <div class="footer">
      <hr />
      &copy; 2025 Matt Hall, Equinor // <a href="https://github.com/equinor/label-ai">GitHub</a>
    </div>

  </div> <!-- End page container -->

  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
  <script>
    // Copyright 2025 Matt Hall, Equinor // MIT license
    $('.collapse').collapse();
    const labelButton = document.getElementById('labelButton');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const labelOptions = document.getElementsByName('labelOption');
    const modelDropdown = document.getElementById('modelDropdown');
    const freeInput = document.getElementById('freeInput');
    const imageFrame = document.getElementById('imageFrame');
    const placeholderText = document.getElementById('placeholderText');
    const popoverContainer = document.getElementById('popoverContainer');
    let image = new Image();
    let originalImageSrc = null; // Store the original image source
    const uploadImageLink = document.getElementById('uploadImageLink');

    // Image upload click.
    uploadImageLink.addEventListener('click', (event) => {
        event.preventDefault(); // Stop the link from navigating

        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        fileInput.onchange = (e) => {
            loadImageFromFile(e.target.files[0]);
        };
        fileInput.click();
    });

    // Initialize C2PA stuff.
    let c2paSdk;
    let generateVerifyUrl;
    let getManifestSummaryStore;

    document.addEventListener('DOMContentLoaded', async () => {
      const version = '0.30.9';
      const c2paLibraryUrl = `https://cdn.jsdelivr.net/npm/c2pa@${version}/+esm`;
      const c2paWcLibraryUrl = `https://cdn.jsdelivr.net/npm/c2pa-wc/+esm`;

      try {
        // Import createC2pa and generateVerifyUrl from the c2pa library
        const c2paModule = await import(c2paLibraryUrl);
        generateVerifyUrl = c2paModule.generateVerifyUrl;

        // Import getManifestSummaryStore from the c2pa-wc library
        const c2paWcModule = await import(c2paWcLibraryUrl);
        getManifestSummaryStore = c2paWcModule.getManifestSummaryStore;

        // Initialize c2paSdk
        c2paSdk = await c2paModule.createC2pa({
          wasmSrc: `https://cdn.jsdelivr.net/npm/c2pa@${version}/dist/assets/wasm/toolkit_bg.wasm`,
          workerSrc: `https://cdn.jsdelivr.net/npm/c2pa@${version}/dist/c2pa.worker.min.js`,
        });
        console.log('C2PA SDK initialized successfully.');

      } catch (err) {
        console.error('Error initializing C2PA SDK or importing libraries:', err);
      }
    });

    // Disable dropdown if not selected.
    labelOptions.forEach(option => {
        option.addEventListener('change', () => {
            if (option.value === 'model') {
            modelDropdown.disabled = false;
            } else {
            modelDropdown.disabled = true;
            }
        });
    });

    // Copy image to clipboard function.
    async function copyCanvasImageToClipboard(canvasElement) {
      try {
        // 1. Get the image data as a Blob from the canvas
        const blob = await new Promise(resolve => canvasElement.toBlob(resolve, 'image/png'));

        // 2. Create a ClipboardItem with the image Blob
        const clipboardItem = new ClipboardItem({
          [blob.type]: blob
        });

        // 3. Write the ClipboardItem to the clipboard
        await navigator.clipboard.write([clipboardItem]);

        console.log('Image copied to clipboard!');
      } catch (err) {
        console.error('Failed to copy image:', err);
      }
    }

    // Label It button.
    labelButton.addEventListener('click', () => {
    const selectedOption = Array.from(labelOptions).find(option => option.checked).value;
    const fontSize = canvas.width / 30;
  
    if (selectedOption === 'generated') {
        const label = "üî∫ Generated by AI";
        ctx.drawImage(image, 0, 0);
        ctx.font = `${fontSize}px Arial`;
        ctx.fillStyle = 'white';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.strokeText(label, fontSize, canvas.height - fontSize);
        ctx.fillText(label, fontSize, canvas.height - fontSize);

    } else if (selectedOption === 'model') {
        const label = `üî∫ Generated by ${modelDropdown.value}`;
        ctx.drawImage(image, 0, 0);
        ctx.font = `${fontSize}px Arial`;
        ctx.fillStyle = 'white';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.strokeText(label, fontSize, canvas.height - fontSize);
        ctx.fillText(label, fontSize, canvas.height - fontSize);

    } else if (selectedOption === 'ai-label') {
        const overlayImage = new Image();
        const w = canvas.width / 8;
        const h = w / 2.617;
        overlayImage.crossOrigin = "anonymous";
        overlayImage.src = "https://raw.githubusercontent.com/ecogex/ai-label/refs/heads/main/image-pack/ai-label_banner-made-with-ai.svg";
        overlayImage.onload = () => {
        ctx.drawImage(image, 0, 0);
        ctx.drawImage(overlayImage, canvas.width - w - fontSize, canvas.height - h - fontSize, w, w/2.617);
        };

    } else if (selectedOption === 'free') {
        const label = `${freeInput.value}`;
        ctx.drawImage(image, 0, 0);
        ctx.font = `${fontSize}px Arial`;
        ctx.fillStyle = 'white';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.strokeText(label, fontSize, canvas.height - fontSize);
        ctx.fillText(label, fontSize, canvas.height - fontSize);
    }

    // Steganography.
    const secretText = document.getElementById('hiddenPrompt').value;
    if (secretText.length > 0) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      const binary = [...unescape(encodeURIComponent(secretText))]
        .map(char => char.charCodeAt().toString(2).padStart(8, '0'))
        .join('') + '00000000'; // add null terminator

      const maxLen = Math.floor(data.length / 4); // One byte per pixel alpha
      if (binary.length > maxLen) {
        alert("Message too long to encode in this image.");
        return;
      }

      for (let i = 0; i < binary.length; i++) {
        const alphaIndex = i * 4 + 3;
        const originalAlpha = data[alphaIndex];
        const bit = binary[i];
        data[alphaIndex] = (originalAlpha & 0b11111110) | parseInt(bit);
      }
      ctx.putImageData(imageData, 0, 0);
    }

    // Always place image on clipboard.
    copyCanvasImageToClipboard(canvas);
  
    });

    // Clear button.
    document.getElementById('clearButton').addEventListener('click', () => {
      if (originalImageSrc) {
        loadImageFromURL(originalImageSrc);
      } else {
        placeholderText.classList.remove('d-none');
        canvas.classList.add('d-none');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    });

    // Drag-and-drop option.
    imageFrame.addEventListener('dragover', (event) => {
    event.preventDefault();
    imageFrame.classList.add('dragover');
    });
    imageFrame.addEventListener('dragleave', () => {
    imageFrame.classList.remove('dragover');
    });
    imageFrame.addEventListener('drop', (event) => {
    event.preventDefault();
    imageFrame.classList.remove('dragover');
    const file = event.dataTransfer.files[0];
    if (file && file.type.startsWith('image/')) {
        loadImageFromFile(file);
    }
    });

    // Ctrl-V option.
    document.addEventListener('paste', (event) => {
    const items = event.clipboardData.items;
    for (let i = 0; i < items.length; i++) {
        if (items[i].type.startsWith('image/')) {
        const blob = items[i].getAsFile();
        loadImageFromBlob(blob);
        break;
        }
    }
    });

    // Load image from a file.
    function loadImageFromFile(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
        loadImageFromURL(e.target.result);
    };
    reader.readAsDataURL(file);
    }

    // Load image from a blob.
    function loadImageFromBlob(blob) {
    const reader = new FileReader();
    reader.onload = (e) => {
        loadImageFromURL(e.target.result);
    };
    reader.readAsDataURL(blob);
    }

    // Decode the steganographic prompt, if present.
    function decodeAlphaMessageFromCanvas() {
      const secretInput = document.getElementById('hiddenPrompt');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      let binary = '';
      let nonOpaqueAlphaFound = false;

      for (let i = 3; i < data.length; i += 4) {
        const alpha = data[i];
        if (alpha !== 255) nonOpaqueAlphaFound = true;
        binary += (alpha & 1).toString(); // LSB
      }

      if (!nonOpaqueAlphaFound) {
        secretInput.placeholder = "E.g. Model, version, date, prompt...";
        return;
      }

      const chars = [];
      for (let i = 0; i < binary.length; i += 8) {
        const byte = binary.slice(i, i + 8);
        if (byte.length < 8) break;
        const code = parseInt(byte, 2);
        if (code === 0) break; // Null terminator
        chars.push(String.fromCharCode(code));
      }

      try {
        const message = chars.join('');
        secretInput.placeholder = message || "(no prompt found, you can add one)";
      } catch (e) {
        secretInput.placeholder = "(error decoding prompt)";
        console.log(e);
      }
    }

    // Load image and read its C2PA data if present.
    function loadImageFromURL(url) {
      const image = new Image();
      image.onload = async () => {
        
        // 0. Remove any popover.
        popoverContainer.classList.add('d-none');

        // 1. Show canvas and hide placeholder.
        placeholderText.classList.add('d-none');
        canvas.classList.remove('d-none');
        originalImageSrc = url; // Save original

        // 2. Set canvas dimensions and draw image.
        canvas.width = image.width;
        canvas.height = image.height;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);

        // 3. Position the cai-popover relative to the image.
        const canvasRect = canvas.getBoundingClientRect();
        const imageFrameRect = imageFrame.getBoundingClientRect();

        // Calculate the top and right offset for the popover relative to the imageFrame.
        // Add some padding (e.g., 10px) from the image edges.
        const popoverTop = canvasRect.top - imageFrameRect.top + 10;
        const popoverRight = imageFrameRect.right - canvasRect.right + 10;
        popoverContainer.style.top = `${popoverTop}px`;
        popoverContainer.style.right = `${popoverRight}px`;

        // Steganographic message.
        decodeAlphaMessageFromCanvas();

        // C2PA metadata, if available.
        if (c2paSdk) { 
          try {
            const { manifestStore } = await c2paSdk.read(url);
            popoverContainer.classList.remove('d-none');
            const manifestSummary = getManifestSummaryStore(manifestStore);
            console.log('manifestStore', manifestStore);
            console.log('manifestSummaryStore', manifestSummary);
            document.getElementById('manifest-summary-issuer').innerHTML = manifestStore.activeManifest?.signatureInfo?.issuer || 'N/A';
            let date = manifestStore.activeManifest?.signatureInfo?.time || 'N/A';
            document.getElementById('manifest-summary-date').innerHTML = date.split('T')[0]
            document.getElementById('manifest-summary-title').innerHTML = manifestStore.activeManifest?.title || 'N/A';
            document.getElementById('manifest-summary-recorder').innerHTML = manifestSummary?.recorder || 'N/A';
            document.getElementById('manifest-summary-content-tag').innerHTML = manifestSummary?.contentSummaryTag || 'N/A';
          } catch (err) {
            console.error('Error reading C2PA data from image:', err);
            popoverContainer.classList.add('d-none');
          }
        } else {
          console.warn('C2PA SDK not initialized. Cannot read C2PA data.');
          popoverContainer.classList.add('d-none');
        }
      };
      image.src = url;
    }
    
</script>
</body>
</html>